/**
 * Generate TypeScript decl for options in node-libtidy
 *
 * @author Wang Guan <momocraft@gmail.com>
 *
 * vim: shiftwidth=2
 */

import * as fs from 'fs';
import * as path from 'path';
import * as dom from 'dts-dom';
import { expect } from 'chai';

// a bootstrap declaration is required to call libtidy.TidyDoc.getOptionList()
import * as libtidy from '../';

/**
 * Main entrypoint: generate and update ../src/index.d.ts
 */
function main() {
  const dts = path.join(__dirname, ...'../src/options.d.ts'.split('/'));
  const content = generate();

  fs.writeFileSync(dts, content);
  console.log(`successfully generated ${dts}`);
  process.exit(0);
}

main();

/**
 * Create type for union of constants
 * @return dom.Type
 */
function createConstUnion(values: (number | string)[]) {
  const v = values.map(_ => typeof _ === "string" ? JSON.stringify(_) : _);
  const u = v.map(_ => dom.create.namedTypeReference(<any>v));
  return dom.create.union(u);
}

/**
 * re-indent lines generated by dts-dom
 * @param lines lines to format
 */
function format(lines: string[]) {
  return lines
    .map(l => l.replace(/^\s+/, headSpaces => headSpaces.substring(0, headSpaces.length / 2)))
    .join("\n");
}

function uniq<T>(items: T[], eq?: (a1: T, a2: T) => boolean) {
  const result: T[] = [];
  for (const i of items) {
    if (!result.some(v => eq ? eq(i, v) : i === v))
      result.push(i);
  }
  return result;
}

/**
 * Change "skip-nested" to "skip_nested"
 */
function camelCaseName(optionName: string) {
  return optionName
    .split('-')
    .map(upperFirst)
    .join('');
}

/**
 * Change "skip-nested" to "skip_nested"
 * @param optionName option name in '-' notation
 */
function underscoreName(optionName: string) {
  return optionName.replace(/-/g, '_');
}

function upperFirst(word: string) {
  return word.replace(/(^.)/, (m: any, $1: string) => $1.toUpperCase());
}

/**
 * Enumerate variants of option name
 *
 * @param {string} optionName
 * @returns {string[]} variants
 */
function enumerateNames(optionName: string) {
  const name1 = optionName;
  const name2 = underscoreName(optionName);
  const name3 = camelCaseName(optionName);
  return uniq([name1, name2, name3]);
}

/**
 *
 *
 * @param {libtidy.TidyOption} o the option
 * @returns {dom.Type} A union type that can be used to set/get the option
 */
function nameUnion(o: libtidy.TidyOption): dom.Type {
  const names = enumerateNames(o.name).map(n => JSON.stringify(n));

  const t = (names.length === 1)
    ? dom.create.namedTypeReference(names[0])
    : dom.create.union(names.map(dom.create.namedTypeReference));
  return t;
}

/**
 * throw if our expectation of libtidy is incorrect
 */
function validateOption(d: libtidy.TidyDoc, o: libtidy.TidyOption) {
  if (o.readOnly)
    return;

  if (o.type === 'integer' && o.pickList.length) {
    // integer and a non-empty picklist:
    // optGet() return normalized value
    o.pickList.forEach((value, i) => {
      expect(d.optSet(<any>o.name, i)).to.eq(undefined);
      expect(d.optGet(<any>o.name)).to.eq(value);

      expect(d.optSet(<any>o.name, value)).to.eq(undefined);
      expect(d.optGet(<any>o.name)).to.eq(value);
    });

  } else if (o.type === 'integer') {
  } else if (o.type === 'boolean') {
    expect(typeof d.optGet(<any>o)).eq("boolean");
    expect(typeof d.optGet(<any>o.name)).eq("boolean");
    expect(typeof d.optGet(<any>o.id)).eq("boolean");

    // optSet a boolean option returns undefined
    expect(d.optSet(<any>o, true)).eq(undefined);
    expect(d.optSet(<any>o, false)).eq(undefined);
  } else if (o.type === 'string') {
  } else
    throw new Error(`not implemented for option type '${o.type}'`);

}

function optGet(o: libtidy.TidyOption): dom.MethodDeclaration {
  const method = dom.create.method("optGet",
    [dom.create.parameter("key", nameUnion(o))],
    valueType(o, "get"));

  const jsdoc = [`${o.category} / ${o.name} (${o.type})`];
  method.jsDocComment = jsdoc.join("\n");

  return method;
}

function optSet(o: libtidy.TidyOption): dom.MethodDeclaration {
  const method = dom.create.method("optSet",
    [dom.create.parameter("key", nameUnion(o)), dom.create.parameter("value", valueType(o, "set"))],
    dom.create.namedTypeReference("void")
  )
  return method;
}

/**
 * the type for available option values
 * @param o
 * @param use: type for get or set, setter accepts a wider range of values
 */
function valueType(o: libtidy.TidyOption, use: "set" | "get"): dom.Type {

  if (o.type === "integer") {
    if (!o.pickList.length) {
      return dom.create.namedTypeReference("number");
    }

    const optionValues = o.pickList.map(v => JSON.stringify(v));

    if (use === 'set') {
      // when setting: number can be used as well
      for (let i = o.pickList.length; --i >= 0;) {
        optionValues.splice(i + 1, 0, <any>[i]);
      }
    }

    const u = optionValues.map(<any>dom.create.namedTypeReference);
    return dom.create.union(<any>u);
  } else if (o.type === "string") {

    if (!o.pickList.length) {
      return dom.create.namedTypeReference("string");
    }
    return dom.create.union(
      o.pickList.map(v => dom.create.namedTypeReference(JSON.stringify(v)))
    )

  } else if (o.type === "boolean") {
    return dom.create.namedTypeReference("boolean");
  }

  throw new Error(`not implemented for option type '${o.type}'`);
}

/**
 *
 *
 * @returns {string} A long string of `namespace Generated ...`
 */
function generate(): string {
  const doc = new libtidy.TidyDoc() as any;
  const options = doc.getOptionList();

  const nm = dom.create.namespace("Generated");
  nm.flags = dom.DeclarationFlags.Export;
  nm.jsDocComment = `
Type for libtidy options
@generated with /util/gen-typescript-decl.ts
    `.trim();

  // type of TidyDoc.options
  const optionDict = dom.create.interface("OptionDict");
  optionDict.jsDocComment = `
NOTE: some values will not be returned from getter.
TypeScript does not allow us to distinguish setter and getter in declaration.
`.trim();
  // optGet / optSet overloads in TidyDoc
  const optAccessors = dom.create.interface('TidyDocOption');

  for (const o of options) {
    validateOption(doc, o);
  }

  for (const o of options) {
    optAccessors.members.push(optGet(o));

    optAccessors.members.push(optSet(o));

    optionDict.members.push(
      dom.create.property(
        underscoreName(o.name),
        valueType(o, "set"),
        dom.DeclarationFlags.Optional));
  }
  nm.members.push(optAccessors);
  nm.members.push(optionDict);
  const lines = dom.emit(nm).split(/\r\n|\n/);
  return format(lines);
}
